>>>>Linux下共享内存的坑
http://www.cnblogs.com/hicjiajia/archive/2012/05/17/2506632.html

最重要的是： 共享内存不会随着进程结束而结束！所以如果不是正常退出的话，一定要在创建的时候发现存在就删除
Linux下的共享内存貌似可以直接调整大小
连接/断开 操作与 打开/删除操作是分开的
server:打开 连接 断开 删除 client:打开 连接 断开 即可
一个被删除的SM不能再被连接，但是已经连接的依旧可以使用，所有连接都断开后会真正删除

>>>>>目前使用IPC发现的问题
由于Linux的IPC相关对象无法像windows那样在进程退出后（不管什么原因）都自动释放，所以开放给app使用，如何清理是个大问题（可能需要修改内核？）

>>>>>>实现MsgQueue的问题
试着在不考虑性能的情况下，在用户态实现了msg queue(还是蛮复杂的)
除开性能问题，这种有可能和user app竞争一个lock的设计，都可能有问题：如果user app因为某些原因卡住了没有释放root tree进程需要的一个锁(PostMsg的时候就要拿一个user app会用的锁)，那么root tree进程就有可能会卡住，导致整个系统失去响应

以后所有跨进程的对象，都有可能导致以上问题。解决方法是？
1.在内核态实现，这样就不存在这个问题
2.使用精心设计的lock free算法？避开锁?