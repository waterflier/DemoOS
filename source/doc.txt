>>>>Linux下共享内存的坑
http://www.cnblogs.com/hicjiajia/archive/2012/05/17/2506632.html

最重要的是： 共享内存不会随着进程结束而结束！所以如果不是正常退出的话，一定要在创建的时候发现存在就删除
Linux下的共享内存貌似可以直接调整大小
连接/断开 操作与 打开/删除操作是分开的
server:打开 连接 断开 删除 client:打开 连接 断开 即可
一个被删除的SM不能再被连接，但是已经连接的依旧可以使用，所有连接都断开后会真正删除

>>>>>目前使用IPC发现的问题
由于Linux的IPC相关对象无法像windows那样在进程退出后（不管什么原因）都自动释放，所以开放给app使用，如何清理是个大问题（可能需要修改内核？）

>>>>>>实现MsgQueue的问题
试着在不考虑性能的情况下，在用户态实现了msg queue(还是蛮复杂的)
除开性能问题，这种有可能和user app竞争一个lock的设计，都可能有问题：如果user app因为某些原因卡住了没有释放root tree进程需要的一个锁(PostMsg的时候就要拿一个user app会用的锁)，那么root tree进程就有可能会卡住，导致整个系统失去响应

以后所有跨进程的对象，都有可能导致以上问题。解决方法是？
1.在内核态实现，这样就不存在这个问题
2.使用精心设计的lock free算法？避开锁?

>>>>>>>>实现Timer的问题
1.用信号机制？
 内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。 

所谓等到返回用户态，任何一个进程都可以在任意执行情况被调度，所以实际上是在任意UseMode的代码执行期都可能跳到信号的处理函数。这会带来 "数据是否是信号安全的问题"

在线程里安装信号？

2.用MsgQueue
起一个后台线程，while(1) select(NULL,NULL,NULL,timeout) ，然后给需要timer的thread发送MSG_TIMER
Timer只会在下个MsgFrame被触发，比较容易编写正确的代码